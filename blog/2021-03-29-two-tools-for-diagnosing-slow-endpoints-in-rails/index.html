<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<title>Two Tools for Diagnosing Slow Endpoints in Rails &#183; Cassidy Scheffer</title>
<link rel=stylesheet href=/css/style.css>
<link rel=stylesheet href=/css/fonts.css>
<link rel=icon href=favicon.ico>
<link rel=icon type=image/png sizes=32x32 href=/images/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/images/favicon-16x16.png>
<link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png>
<link href rel=alternate type=application/rss+xml title="Cassidy Scheffer">
</head>
<body>
<nav class=nav>
<div class=nav-container>
<a href=/>
<h2 class=nav-title>Cassidy Scheffer</h2>
</a>
<ul>
<li>
<a href=/blog/>
<span>Posts</span>
</a>
</li>
<li>
<a href=https://github.com/cassidycodes>
<span>GitHub</span>
</a>
</li>
<li>
<a href=https://www.linkedin.com/in/cassidyscheffer/>
<span>LinkedIn</span>
</a>
</li>
</ul>
</div>
</nav>
<main>
<div class=post>
<div class=post-info>
<span>Written by</span>
Cassidy Scheffer
<br>
<span>on&nbsp;</span><time datetime="2021-03-29 10:31:01 -0500 -0500">March 29, 2021</time>
</div>
<h1 class=post-title>Two Tools for Diagnosing Slow Endpoints in Rails</h1>
<div class=post-line></div>
<p>##Intro</p>
<p>In general, I see two types of slow endpoints when I am doing performance work: endpoints that have bad code causing a slow response, and endpoints that have a bad query causing a slow response. This post will focus on endpoints that have bad code.</p>
<p>Slow endpoints can be identified using an application performance monitor like NewRelic. These endpoints usually either have <a href=https://en.wikipedia.org/wiki/N%2B1_redundancy>N + 1 queries</a>, or they spend lots of time in Ruby. You’ll see them in NewRelic, but if you want to hit an endpoint in real-time with production data, see the tip below about Rack MiniProfiler.</p>
<p>###NewRelic</p>
<p>The transactions monitor is a good place to start. Pick a broad time range (7 days) and look at the “Transaction Traces” that New Relic has captured. If a transaction trace here includes a long query or lots of queries to the DB, it is likely a good transaction to look into.</p>
<p>There will likely also be some obvious problem queries in the top “Most Time Consuming” transactions. Click through each transaction here and take a look at the transaction traces that NewRelic captured.</p>
<p>The example below has two N + 1 problems! First you see that we hit Memcached 62 times, then we hit the relational database 47 times! Eeep! Looks like this is a good endpoint to work on.</p>
<p><img src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/h2xz4cm73c9vtqg45zq8.png alt="alt text"></p>
<p>“Most Time Consuming” is not a bad thing. If we have a really fast endpoint that is hit tens of thousands of time per minute, it is not really a problem. But if a relatively busy endpoint has a slow average response time, it likely is a problem!</p>
<p>###Rack MiniProfiler</p>
<p>Development and staging data can differ wildly from production data, which makes query performance differ wildly between the environments.</p>
<p>Running Rack MiniProfiler in production gives you a real-time stack trace of live production data! Check out <a href=https://github.com/MiniProfiler/rack-mini-profiler#access-control-in-non-development-environments>the Rack MiniProfiler docs on how to run it in a production environment</a></p>
<p>I like to be able to selectively turn Rack MiniProfiler on and off, so I usually set it up so that you have to log in as an admin user and then you have to have turned it on for your session by adding <code>?rmp=on</code> to the first request.</p>
<p>Once Rack MiniProfiler is turned on, you can hit one of the problem endpoints that you see in NewRelic and get more detailed information on what is slowing that request down.</p>
<p>###4 Possible Ways to Resolve Slow Endpoints</p>
<p>This is a non-exhaustive list of possible solutions.</p>
<ul>
<li>Find an N + 1? Solve it! You’ll see these in either NewRelic or in Rack Mini Profiler. Solving an N + 1 can mean either eager-loading data using <a href=https://devdocs.io/rails~5.2/activerecord/querymethods#method-i-includes><code>includes</code></a>, or loading the necessary data in a separate query. It’s usually best to start with using <code>includes</code>, and if causes performance issues, try using separate queries.</li>
<li>Add or improve caching
<ul>
<li>Can the data being queried be cached, or can you use Russian Doll Caching to cache view partials?</li>
<li>Can you improve the cache usage by selecting multiple records from the cache rather than doing N + 1 queries to the cache? <a href=https://devdocs.io/rails~5.2/activesupport/cache/store#method-i-fetch_multi>Check out the docs on <code>select_multi</code></a> to see how we might resolve the 62 queries to the cache in the example above.</li>
</ul>
</li>
<li>Here&rsquo;s an odd one that you&rsquo;ll find in older applications: Do you even need to display this data? Or do you to display this data with the resolution you are showing? Sometimes older pages slow down because we are trying to show a count of all data from the beginning of time!</li>
</ul>
<p>Remember, performance work can take a few passes to get it right. Try one strategy at a time, deploy, and monitor until your response time is back to an acceptable level.</p>
<p>I&rsquo;d love to hear your favourite strategies for tackling slow endpoints.</p>
</div>
<div class=pagination>
<a href=/blog/2021-06-25-how-to-test-rake-tasks-with-rspec-without-rails/ class="left arrow">&#8592;</a>
<a href=/blog/2021-04-09-speeding-up-order-by/ class="right arrow">&#8594;</a>
<a href=# class=top>Top</a>
</div>
</main>
<footer>
<span>
&copy; <time datetime="2022-02-26 17:06:33.577854117 +0000 UTC m=+0.248045240">2022</time> Cassidy Scheffer. Made with <a href=https://gohugo.io>Hugo</a> using the <a href=https://github.com/EmielH/tale-hugo/>Tale</a> theme.
</span>
</footer>
</body>
</html>